# Prefix Sum, Josephus Permutation

## Ⅰ. Introduction

> - 구간 합 알고리즘 조세퍼스 순열 의의
> - 각 모델 구현 및 활용 예제

## Ⅱ. Prefix Sum : 구간 합

### 1. 의의

1차원 배열에서 i~j 사이의 값들의 합을 구하는 데 사용한다. Brute Force로 단순히 for문을 이용할 경우에 비해 구간 합 알고리즘을 활용하면 시간복잡도를 개선할 수 있다.

itertools를 활용하여 계산 가능하다.

```python
from itertools import accumulate

n, s = map(int, input().split())
sl = list(map(int, input().split()))
# sl = [1, 2, 3, 4, 5] 인 경우
ps = list(accumulate(sl))
# ps = [1, 3, 6, 10, 15]
```

### 2. 예제 - 재벌의 쇼핑

#### (1). Intro

```
흔히 재벌들이 나오는 드라마나 영화를 시청할 때, 재벌들이 백화점에 가면 “여기부터 저기까지 다 주세요.” 같은 방식으로 쇼핑을 하곤 합니다.

복권에 당첨되어 큰돈을 얻은 도도새는 재벌처럼 쇼핑해보려 합니다. 도도새가 간 백화점에는 N개의 상품이 일렬로 나열되어 있었고 1번부터 N 번의 번호를 가집니다. 각 상품의 가격은 10,000 이하의 자연수 값을 가진다고 합니다.

도도새는 최소한 S만큼의 금액 이상 쇼핑에 쓰려 합니다. 하지만 양보다 질을 따지기 때문에 최소한의 개수만큼만 구매하려고 합니다.

도도새가 “i번부터 j번까지 다 주세요!”라고 했을 때, 도도새가 구매한 제품 개수의 최솟값을 구하는 프로그램을 작성하세요.
```

#### (2). 입력

```
첫째 줄에 백화점에 진열된 총 상품의 개수를 나타내는 자연수 N과 도도새가 쇼핑에 사용할 최소 금액을 나타내는 자연수 S를 입력합니다.

(10 ≤ N < 1,000)
(0 < S ≤ 100,000)
```

#### (3). 출력

```
도도새가 구매하려는 상품의 최소 개수를 출력합니다.
만일 조건에 맞는 쇼핑이 불가능하다면 0을 출력하면 됩니다.
```

#### (4). 입출력 예시

- 입력

```
10 15
5 1 3 5 10 7 4 9 2 8
```

- 출력

```
2
```

#### (5). 풀이

```python
import itertools

n, s = map(int, input().split())
sl = list(map(int, input().split()))
ps = list(itertools.accumulate(sl))

if ps[-1] < s:
    print(0)
else:
    for i in ps:
        if i >= s:
            ans = ps.index(i)+1
            break
    ps = ps[::-1]
    for i in range(n-ans):
        for j in range(i+1, n):
            if ps[i] - ps[j] >= s:
                if j - i < ans:
                    ans = j - i
                break
    print(ans)
```

시간복잡도 개선을 위해 구간 합 알고리즘 활용한다. 정순으로 값을 구해본 뒤 역순으로 최소값을 갱신한다.

## Ⅲ. Josephus permutation

### 1. 의의

n명이 동그랗게 모여있을 때 임의의 한 명부터 순서를 세어 k번째 사람을 모임에서 제외한다. 이후 제외된 다음 사람부터 동일하게 진행하는 경우 제외되는 사람들의 순서, 마지막으로 제외되는 사람 등을 파악하기 위한 순열이다.

```python
n, k = map(int,input().split())

people = [i for i in range(1, n+1)]
temp = k - 1
josephus = []

while True:
    josephus.append(people.pop(temp))
    if not people:
        break
    temp = (temp + k - 1) % len(people)
```

### 2. 예제 - 파자마 파티

#### (1). Intro

```
하트 여왕은 파자마 파티를 열었습니다. 파자마 파티는 잠옷을 입고 밤새우면서 노는 것을 말합니다.
하트 여왕의 파자마 파티에는 총 N명의 친구가 왔습니다. 그리고 하트 여왕은 친구들과 게임을 하려고 합니다.

친구들 N명은 1번부터 N 번까지 시계방향으로 원형으로 앉았습니다. 1번부터 한 명씩 시계방향으로 1, 2, … , K까지 셉니다.
K를 말하는 사람은 원에서 나갑니다. 그 후에는 다음 자리에 앉아있는 사람이 1부터 다시 셉니다.
하트 여왕도 이 게임에 M 번으로 참가합니다. 하트 여왕은 자기가 몇 번째로 원에서 나가는지 궁금해졌습니다.

N, K, M이 주어졌을 때, 하트 여왕이 몇 번째로 원에서 나가는지 알아내는 프로그램을 작성하세요.
```

#### (2). 입력

```
첫째 줄에 N, K, M을 입력합니다.
N과 K는 5,000,000보다 작거나 같은 자연수이고, M은 N보다 작거나 같습니다.
```

#### (3). 출력

```
첫째 줄에 하트 여왕이 몇 번째로 원에서 나가는지 출력합니다.
```

#### (4). 입출력 예시

- 입력

```
10 5 3
```

- 출력

```
10
```

#### (5). 풀이

```python
n, k, m = map(int,input().split())

josephus = [i for i in range(1, n+1)]
temp = k - 1

while m in josephus:
    josephus.pop(temp)
    if not josephus:
        break
    temp = (temp + k - 1) % len(josephus)

result = n - len(josephus)

print(result)
```

시간 복잡도 개선을 위해 조세퍼스 순열에서 m번째 사람이 나가는 경우까지만 계산하였다.

## Ⅳ. 결론 & 느낀 점

> - 알고리즘 문제 풀이에 필요한 도구를 이해하고 구현해보며 이를 통해 연산을 개선할 수 있다는 것은 흥미롭다.
> - 이러한 방법이 있구나 하는 것만 알면 조금만 응용하여 문제를 효율적으로 해결할 수 있을 것 같았다. 많은 것을 알아갈 수 있도록 부지런히 공부하자
