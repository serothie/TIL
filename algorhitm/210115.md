# Prefix Sum, Josephus Permutation

## Ⅰ. Introduction

> - 분할 정복, 에라토스테네스의 체 의의
> - 각 모델 구현 및 활용 예제

## Ⅱ. Sieve of Eratosthenes : 에라토스테네스의 체, 소수 구하기

### 1. 의의

소수를 구하기 위한 알고리즘이다. Brute Force로 for문을 이용해 N까지의 숫자 중 소수를 찾는 경우보다 시간복잡도가 개선된다.

```python
n = int(input())

sieve = [False,False] + [True] * (n-1)

for i in range(2,n+1):
    if sieve[i]:
        for j in range(2*i, n+1, i):
            sieve[j] = False
```

인덱스 값이 2의 배수에 위치하는 경우 False로 체크되고 for문의 if문에서 pass 되므로 빠르게 소수를 판별할 수 있다.

### 2. 예제 - 소수의 법칙

#### (1). Intro

```
소수를 관찰하던 공준이는 특별한 규칙을 발견했습니다. 어떤 자연수 N을 관찰하든 간에 N보다 크고 2N보다 작거나 같은 소수는 언제나 한 개 이상 존재한다는 것입니다.

예를 들어, N이 14인 경우 14보다 크고 28 이하인 소수는 17, 19, 23, 총 3개가 있습니다.

N이 주어졌을 때, N보다 크고 2N보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하세요.
```

#### (2). 입력

```
자연수 N을 입력합니다.

(1<=N<=123,456)
```

#### (3). 출력

```
N보다 크고, 2N보다 작거나 같은 소수의 개수를 출력합니다.
```

#### (4). 입출력 예시

- 입력

```
14
```

- 출력

```
3
```

#### (5). 풀이

```python
n=int(input())

web = [False,False] + [True] * (2*n-1)

for i in range(2,2*n+1):
    if web[i]:
        for j in range(2*i, 2*n+1, i):
            web[j] = False

print(web[n+1:].count(True))
```

## Ⅲ. Divide and Conquer : 분할 정복

### 1. 의의

입력 값을 그대로 처리하기 어려운 경우 이를 작은 값으로 분할하여 문제를 해결하는 알고리즘
입력 값이 커서 시간복잡도가 문제되는 경우 입력 값을 분할하여 동시에 처리한다.

### 2. 예제 - 산수 왕 체셔

#### (1). Intro

```
초등학생인 체셔는 또래 친구들보다 수학을 잘했습니다. 그래서 다른 친구들이 덧셈과 뺄셈을 배울 때 체셔는 곱셈과 나눗셈까지 알고 있었기에 수업 시간이 지루했습니다. 그래서 수학 선생님은 체셔에게 특별 숙제를 내주었습니다.

수학 선생님은 다른 친구들이 수업을 들을 동안 체셔에게 아주 큰 자연수 A 를 B 번 곱한 다음, C 로 나누어 보라고 하였습니다.

체셔는 숙제를 보고 너무 쉬워서 코웃음 쳤습니다.

체셔가 문제를 빠르게 풀 수 있도록 프로그램을 작성하세요.
```

#### (2). 입력

```
자연수 A, B, C를 공백으로 구분하여 한 줄에 입력합니다.

(1 <= A, B, C <= 2,147,483,647)
```

#### (3). 출력

```
A 를 B 번 곱한 수를 C 로 나눈 나머지를 출력합니다.
```

#### (4). 입출력 예시

- 입력

```
10 11 12
```

- 출력

```
4
```

#### (5). 풀이

```python
A, B, C = list(map(int, input().split(' ')))

def solution(A, B):
    if B == 1:
        return A % C
    else:
        value = solution(A, B//2)
        if B % 2 == 0:
            return value * value % C
        else:
            return value * value * A % C

print(solution(A, B))
```

결론적으로 기존의 10^11 을 12로 나눈 나머지를 구하는 연산에서
이를 충분히 작은 수로 쪼갠 수를 12로 나눈 나머지들을 이용해 모듈러 연산을 반복한다.

예제의 경우 100을 12로 나눈 나머지를 제곱하여 10과 곱한 뒤, 즉 (100%12)^2 에 10을 곱한 뒤 다시 12로 나눈 나머지를 구한다.

이는 10^5 를 12로 나눈 나머지이다. 이 결과를 다시 제곱한 뒤 10을 곱하여 12로 나눈 나머지를 구하는 연산은 pow(10, 11, 12)와 같다.

## Ⅳ. 결론 & 느낀 점

> - 하나 하나 배워나가는 것은 흥미롭다. 배울 것은 점점 많아지는 것만 같기도 하다.
> - 더 배우고 더 느끼자
